#+STARTUP: content logdone

* Supporting multiple Python versions
** Python 2
*** DONE Test in Python 2.6
    CLOSED: [2011-11-04 Fri 20:02]
** Python 3
*** DONE Test in Python 3.0
    CLOSED: [2011-11-06 Sun 01:14]
*** DONE Test in Python 3.1
    CLOSED: [2011-11-06 Sun 00:48]
*** DONE Test in Python 3.2
    CLOSED: [2011-11-05 Sat 17:38]
*** DONE Research supporting 2&3 with the same module
    CLOSED: [2011-11-04 Fri 02:32]
    Does setuptools or distutils have some mechanism to automate 2to3 in a
    module installation or something?
*** DONE Add keyword-only arguments support
    CLOSED: [2011-11-05 Sat 23:55]
** Other Python implementations
*** DONE Test in IronPython
    CLOSED: [2011-11-06 Sun 13:14]
    Works in IronPython 2.7.1
*** DONE Test in PyPy
    CLOSED: [2011-11-06 Sun 00:54]
    Works in PyPy 1.6.0
* Partial application decorator
** DONE Look into preserving more function metadata
   CLOSED: [2011-11-05 Sat 17:18]
   Investigate how the @decorator decorator preserves original function
   metadata so that e.g. inspect.getargspec() still returns the original
   result.
** DONE Review __get__ descriptor method
   CLOSED: [2011-11-04 Fri 02:31]
   Is it really necessary to handle instance vs. class and static methods
   separately?  Why did we decide on this approach in the first place?  Why
   does __call__ work here?
* Composition mechanism
** DONE Figure out argspecs for composite functions
   CLOSED: [2011-11-04 Fri 02:16]
   How should we handle argument specifications for composite, partially
   applicable functions?  Should we just attempt to evaluate on the very
   first invocation?
* Unit tests
** DONE Test pointfree on instance, class, static methods 
   CLOSED: [2011-11-05 Sat 01:51]
** DONE Find non-setuptools test execution solution
   CLOSED: [2011-11-05 Sat 01:30]
** DONE Write test for unbound instance, class, static methods
   CLOSED: [2011-11-06 Sun 01:10]
** TODO Look into whether more composite function tests are needed
   Do we need to write more tests for the @pointfree decorator?  What about
   when used with keyword arguments?
** DONE Go over existing unit tests, refactor as necessary
   CLOSED: [2011-11-06 Sun 01:25]
* Documentation
** DONE What's the Pythonic way to present full module documentation?
   CLOSED: [2011-11-06 Sun 15:31]
   Sphinx with reStructuredText?
** TODO Fully specify behavior in inline documentation
** DONE Migrate README.md to reStructuredText
   CLOSED: [2011-11-08 Tue 01:57]
** DONE Add examples to README
   CLOSED: [2011-11-08 Tue 01:57]
** DONE Add Apache License 2.0 info
   CLOSED: [2011-11-06 Sun 16:02]
** TODO Add literate doctest comments
* Misc
** DONE Convert project back to distutils
   CLOSED: [2011-11-05 Sat 01:30]
** DONE Review distutils project layout
   CLOSED: [2011-11-06 Sun 15:24]
   How is this normally done?
** DONE Figure out what happens to methods of old-style objects
   CLOSED: [2011-11-06 Sun 13:03]
   What happens, exactly, when you try to apply the partial or pointfree
   decorator to a method of an old-style class?
** TODO Examine decorator ordering for class/static pointfree methods
   What happens when you apply @staticmethod or @classmethod above
   @pointfree?
** DONE Figure out WTH the descriptors work on old-style classes
   CLOSED: [2011-11-06 Sun 13:03]
   Why is it that we can add a @partial method to an old-style class and
   yet the __get__ descriptor method still seems to work as intended?
** TODO Support receiving a pointfree/partial object in __init__
** TODO Support receiving a functools.partial object in __init__
** TODO Try to support functools.partial __init__ drop-in replacement
   Accept positional and keyword arguments to __init__ as arguments to the
   partial function.  This would require finding another way to specify
   copy_sig= and argv=.
** TODO Rename printfn, ignore to reflect their operation on iterators
** TODO Consider alternate composition operators
   Perhaps use a pipe rather than rshift for forward composition?
